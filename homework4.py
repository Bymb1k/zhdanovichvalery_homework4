# Valery Zhdanovich
# Homework-4
# 04.04.2025 # Отлично, что указал актуальную дату!
# Grodno-IT-Academy-Python 3.9.6

# Хорошая работа, Валерий! Код в целом чистый и выполняет поставленные задачи.
# Давай посмотрим на детали.

# теперь тесты написаны с использованием библиотеки pytest
# нам нужно ее установить: pip install pytest
# и запустить как обычный файл: pytest test_Homework4.py
# Теперь вы будете знакомы со вторым инструментом для тестирования
# Спасибо за напоминание про pytest!

#Выведите n-ое число Фибоначчи, используя только временные переменные, циклические операторы и условные операторы. n - вводится.
def fibonacci(n):
    # Проверка на отрицательные значения
    # Отличная практика - проверять входные данные на корректность.
    # Хотя тесты не проверяют отрицательные n, это делает функцию более надежной.
    if n < 0:
        raise ValueError("n должно быть неотрицательным числом")

    # Базовые случаи для 0 и 1
    # Здесь ты реализуешь классическую последовательность Фибоначчи: F(0)=0, F(1)=1, F(2)=1, F(3)=2...
    if n == 0:
        return 0
    elif n == 1:
        # Твоя функция возвращает 1 для n=1.
        # Однако тесты (`test_fib_values`) ожидают другую последовательность:
        # F_test(1)=0, F_test(2)=1, F_test(3)=1, F_test(4)=2...
        # То есть, для n=1 тест ожидает 0, а для n=2 ожидает 1.
        # Текущая реализация не пройдет тесты для n > 1.
        return 1  # исправляем, чтобы возвращалось 1 для n == 1 # Комментарий указывает на стандартную последовательность, но она не совпадает с тестами.

    # Инициализация первых двух чисел Фибоначчи
    # Инициализация верна для стандартной последовательности F(0)=0, F(1)=1.
    prev, fib = 0, 1

    # Цикл для нахождения n-го числа Фибоначчи
    # Цикл `range(2, n + 1)` и логика `prev, fib = fib, prev + fib` корректно вычисляют
    # F(n) для стандартной последовательности.
    for _ in range(2, n + 1):
        prev, fib = fib, prev + fib  # Обновляем числа Фибоначчи

    # Возвращается F(n) стандартной последовательности.
    return fib
    # Чтобы пройти тесты, нужно вернуть (n-1)-й член стандартной последовательности (для n>=1).
    # Можно изменить базовые случаи и логику так:
    # if n == 1: return 0
    # if n == 2: return 1
    # a, b = 0, 1
    # for _ in range(2, n): # Цикл до n, а не n+1
    #     a, b = b, a + b
    # return b # Возвращаем b, которое будет соответствовать F_test(n)

    # Рекомендация: Добавь строку документации (docstring) для описания функции.


#Определите, является ли число палиндромом (читается слева направо и справа налево одинаково). Число положительное целое, произвольной длины. Задача требует работать только с числами (без конвертации числа в строку или что-нибудь еще).
def palindrome(n):
    # Отличное решение! Алгоритм работает только с числами, как и требовалось.
    # Если число меньше 0, то оно не может быть палиндромом
    # Корректная обработка отрицательных чисел.
    if n < 0:
        return False

    # Для чисел с одной цифрой всегда True
    # Правильный базовый случай.
    if n < 10:
        return True

    original = n
    reversed_number = 0

    # Инвертируем число
    # Логика разворота числа с помощью целочисленной арифметики реализована верно.
    while n > 0:
        reversed_number = reversed_number * 10 + n % 10  # Берем последнюю цифру и строим число в обратном порядке
        n //= 10  # Убираем последнюю цифру # Отличное использование //=

    # Проверяем, совпадает ли исходное число с инвертированным
    return original == reversed_number
    # Функция должна успешно пройти все тесты.
    # Рекомендация: Тоже добавь docstring.


#Напишите генератор, который возвращает цифры от S до N, но вместо чисел, кратных 3 пишет Fizz, вместо чисел кратный 5 пишет Buzz, а вместо чисел одновременно кратных и 3 и 5 - FizzBuzz.
def fizz_buzz(S, N):
    # Отличная реализация с использованием генератора! Эффективно по памяти.

    # Проверяем порядок: если S > N, меняем порядок на обратный
    # Логика определения шага и диапазона итерации корректна для обоих направлений.
    if S <= N:
        step = 1  # Идем по возрастанию
        start, end = S, N
    else:
        step = -1  # Идем по убыванию
        start, end = S, N
    # Замечание: можно было не вводить start/end, а просто использовать S, N и step в range.
    # Например: `for num in range(S, N + step, step):` Это чуть короче.

    # Использование `range` здесь очень уместно.
    for num in range(start, end + step, step):
        # Порядок проверок (15, 3, 5) правильный.
        if num % 15 == 0:
            yield "FizzBuzz"
        elif num % 3 == 0:
            yield "Fizz"
        elif num % 5 == 0:
            yield "Buzz"
        else:
            yield str(num)  # Преобразуем число в строку # Правильно!
    # Эта функция должна пройти все тесты.
    # Рекомендация: Не забудь добавить docstring.

# Общее впечатление: Хороший, рабочий код. Главный момент - скорректировать `fibonacci` под требования тестов.
# Продолжай писать чистый код и добавлять проверки входных данных и документацию!
